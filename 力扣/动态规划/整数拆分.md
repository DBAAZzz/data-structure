### 整数拆分

描述：

给定一个正整数 `n`，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例：

```js
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

```js
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

#### 解题思路


按照动态规划五部曲

**1、确定 dp 数组以及下标的含义**

dp[i] 表示数字 `i` 能够被拆分的最大乘积

**2、确定递推公式**

那么状态转移方程就是将 `i` 挨个可能拆了，找到最大值

    由于存在这种情况：2 = 1 + 1，dp[2] = 1 * 1 = 1，而当 3 拆分成 1 + 2 时， 1 * 2 是大于 1 * dp[2]的。
    所以我们的代码中要取这两种情况的较大者


**我们可以从 1 开始遍历 j** ，然后有两种渠道得到 dp[i]

一个是 `j * (i - j)` 直接相乘
一个是 `j * dp[i - j]` 

`j * (i - j)` 是单纯的把整数拆分为两个数相乘，而 `j * dp[i -  j]` 是拆分成两个以及两个以上的个数相乘



**3、dp 数组的初始化**

严格从 dp[i] 的定义上来说，dp[0]、dp[1] 就不应该初始化，也就是没有意义的数值。

所以这里只初始化dp[2] = 1，从 dp[i] 的定义来说，拆分数字 2 的最大乘积是 1



#### 实现

```js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
  let dp = new Array(n + 1).fill(0)
  dp[2] = 1
  for(let i = 3; i <= n; i++) {
    for(let j = 1; j < i; j++) {
      dp[i] = Math.max(dp[i], j * dp[i - j], j * (i - j))
    }
  }
  return dp[n]
}
```