### 使用最小花费爬楼梯

描述：

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

示例：

```js
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

```js
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

#### 解题思路

1、确定dp数组以及下标的含义

本题只需要一个一维数组dp[i]就可以了
dp[i]的定义：到达第 i 个台阶所花费的最小体力为 dp[i]。

2、确定递推公式

**可以有两个途径得到dp[i]，一个是 dp[i - 1] 一个是 dp[i - 2] 。**
那么我们该选哪一个？根据题意知：
一定是选最小的，所以 `dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]`

3、dp 数组如何初始化

根据 dp 数组的定义，dp 数组初始化其实是比较困难的，因为不可能初始化为第 i 台阶所花费的最小体力。

那么看一下递归公式，`dp[i]` 由 `dp[i - 1]`，`dp[i - 2]` 推出，既然初始化所有的 `dp[i]` 是不可能的，那么初始化 `dp[0`] 和 `dp[1]` 就可以了。

#### 实现

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  let dp = [cost[0], cost[1]];
  for(let i = 2; i < cost.length; i++) {
    dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i]
  }
  // 最后两个台阶取最小值
  return Math.min(cost[cost.length - 1], cost[cost.length - 2])
};
```