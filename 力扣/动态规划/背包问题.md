### 背包问题

描述：

有N件物品和一个最多能背重量为 W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。


#### 基本思路

用子问题定义状态，`dp[i][j]` 表示只考虑前 `i` 件物品，恰好放入一个容量为 `j` 的背包可以获得的最大价值。则其状态转移方程便是：

    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。

“将前 i 件物品放入容量为 W 的背包中”这个子问题，如只考虑第 i 件物品的策略（放或不放），那么就可以转化为一个只和 `前i - 1` 件物品相关的问题给i。

- 若是不放，那么问题就转化成 **“前i - 1件物品放入容量为 W 的背包中”**，即 `dp[i - 1][j]`
- 如果放进去，那么问题就转化成 **“前 i - 1件物品放入剩下的容量为 W - c[i] 的背包中”**，即 `dp[i - 1][j - c[i]] + w[i]`

**初始化**

我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则没有要求必须把背包装满，一种区别这两种问法的实现方法是在初始化的时候有所不同。关于初始化，一定要和 dp 数组的定义吻合。

1. 没有要求背包装满

首先从 dp[i][j] 的定义触发，如果背包容量 j 为 0 的话，那么无论选取哪些物品，背包价值总和一定为 0。

从状态转移方程中我们知道，i 是由 i - 1 推导出来的，那么 i 为 0 的时候要初始化。同时要保证背包的容量要大于 i 为 0 物品的质量。


#### 实现

```js
function weightBagProblem(wight, value, size) {
  let len = wight.length;
  let dp = [[]]
  // 初始化 dp 数组，给 dp[0][j] 进行赋值
  for (var j = 0; j <= size; j++) {
    if (j < wight[0]) { // 如果容量不能放下物品 0 的重量，那么价值为 0
      dp[0][j] = **0**
    } else { // 否则等于物体 0 的价值
      dp[0][j] = value[0]
    }
  }
  
  for (let j = 0; j <= size; j++) {
    for (let i = 1; i <= len; i++) {
      if (!dp[i]) dp[i] = []
      if (j >= wight[i]) {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wight[i]] + value[i])
      } else {
        // 如果背包容量小于选择的物品
        dp[i][j] = dp[i - 1][j]
      }
    }
  }
  console.table(dp)
  return dp[len][size]
}

```


### 优化空间复杂度

#### 滚动数组

·